import java.util.ArrayList
import java.util.Arrays
import java.util.Comparator
import java.util.HashMap
import java.util.HashSet
import java.util.Interator
import java.util.PiorityQueue

Public Class MaxFeeTXHandler {

      Public static final int VALID=1;
      Public static final int NOTVALID=-1;
      Public static final int POT_Valid=1;
      
      private UTXOPool up;
      
      /* Creates a public ledger whose current UTXOPool (collection of unspent
       * transaction outputs) is utxoPool. This should make a defensive copy of 
       * utxoPool by using  the UTXOPool(UTXOPool uPool) constructor.

       */
      public MaxFeeTxHandler(UTXO utxoPool) {
          up = new UTXOPool(utxoPool);
      }
      
      /* Returns true if
       * (1) all outputs claimed by tx are in the UTXO pool;
       * (2) the signatures on each input of tx are valid,
       * (3) no UTXO is claimed multiple times by tx,
       * (4) all of the tx's output values are non-negative, and
       * (5) the sum of tx's input values are greater that the sum of
             it's output values;
          and false otherwise.
       */
       
       public boolean isValidTx(Transaction tx) {
       
              ArrayList<UTXO> seenUTXO = new ArrayList<UTXO>();
              
              double inSum = 0;
              double outSum = 0;
          
              int index = 0;
              
              for (Transaction.Input in : tx.getInputs()) {
              
                      UTXO checkUTXO = new UTXO(in.prevTxHash, in.outputIndex);
                      if (seenUTXO.contains(checkUTXO)) return false; // 3
                      //no UTXO is claimed multiple times by tx
                      
                      seenUTXO.add(checkUTXO);
                      
                      //if the transaction pool doesn't contain it already
                      if (!up.contains(checkUTXO)) return false;// 1
                      
                      inSum += up.getTxOutput(checkUTXO).address.verifysignature(tx.getRawDataToSign(index), in signature)) return false; //
                      
                      index++;
               }
               
               for (Transaction.Output out : tx.getOutputs()) {
                        
                      
